package HW04.t03;

import java.io.FileOutputStream;
import java.io.IOException;

/**
 * Created by Konstantin on 18.12.2015.
 */
public class CreateUtf8File  {
    public static void fileCreator(String fName, String text) throws IOException {
        try (FileOutputStream fos = new FileOutputStream(fName);){
            fos.write(new String(text.getBytes(), "utf-8").getBytes());
        }
    }

    public static void main(String[] args) throws IOException {
        String path = System.getProperty("user.dir") + "/src/main/resources/" + "utf8file.test";
        CreateUtf8File.fileCreator(path, "Default logger\n" +
                "\n" +
                "Кто в проекте не использует log4j? А можете сходу назвать библиотеки, которые тоже обходятся без него? Думаю это трудные вопросы. Понимаю, java не может подстраиваться под каждую конкретную задачу, но добавили же стандартный Logger, так почему за 10 лет существования log4j, java так и не взяла лучшее из него? Представьте на сколько бы уменьшились все приложения, особенно сложные, где в конечной сборке может оказаться несколько разных версий логера.\n" +
                "\n" +
                "Clonable\n" +
                "\n" +
                "Все знают что интерфейс Clonable пустой, без единого метода и переменной, просто маркер для JVM. Вопрос — почему? Ведь, если наследоваться от него, то мы пытаемся определить некое поведение и следуя парадигмам ООП он должен содержать метод clone(), который и определял бы это самое поведение. Безусловно, иногда очень удобно без переопределения clone получить копию обьекта. Тем не менее, переопределять этот метод, по сути, приходится во всех классах у которых есть хотя бы одна коллекция обьектов модели, чтобы получить полную копию, а не просто ссылки на те же обьекты внутри коллекции. Я не знаю почему разработчики не определили в этом интерфейсе ни одного метода. Надеюсь у них была на это причина, хотя, наверное, просто забыли. Как следствие — метод clone() в Object.\n" +
                "\n" +
                "Serializable\n" +
                "\n" +
                "Ситуация аналогична Clonable, но тут по крайней мере можно возразить — в большинстве случаев \n" +
                "мы не определяем поведение вручную, а полагаемся на стандартную реализацию и было бы очень не удобно постоянно переопределять какие-то методы сериализации + постоянно следить за добавлением новых полей, добавлять их в методы. Ну и специально для этих целей есть Externalizable. Тем не менее, мы знаем, что можно изменить стандартное поведение сериализации предопределив writeObject() и readObject(). Как-то не по ООПшному.\n");
    }
}
